# Loscore リターンズ
### This was created during my time as a [Code Chrysalis](https://codechrysalis.io) Student

これは、皆さんおなじみですね！しかし、いくつかの小さな変更があります。

1.  事前課題では、ブラウザに大きく依存していました。しかし今では、Node が何であるかが理解できているはずです（そう願います。もし理解できていないようなら、Google で検索してください）！ Node を使用して JavaScript を実行することに慣れて、ブラウザへの依存を少し減らしましょう。
2.  `package.json` を流し見して、それぞれの項目を理解できるかどうか確認してください。

注：Lodash および Underscore ライブラリを理解するのは良いことですが、この演習の目的は、高階関数の作成とテストの読み方を練習して上達することにあります。これらの有名なライブラリの "ボンネットの下" で何が起こっているのかを考えてみてください --- どのように処理が行われているのか？そして、あなたが完全に同じことができると理解するために --- それには時間と忍耐が必要です。

## 達成目標

* Node と yarn を使用してテストを実行できるようになる。
* 各メソッドに少なくとも 2 つのテストがあることを確認する。
* 各マイルストーンの終了後にコードをコミットできる。
* 関数を引数として受け取る関数（高階関数）を作成する。
* Jasmine のテストに合格するためのコードを書く。
* 値をハッシュマップとして保存する。
* ハッシュマップから値を取得する。

## セットアップ

Code Chrysalis の git フローの指示に従って、このリポジトリをフォークおよびクローンします。

依存パッケージのインストール：`yarn install`

テストコードを実行するコマンド：`yarn test`

## 基本レベル

以下の問題を解く上で、それぞれの関数がどのように機能するのか、暗記することは重要ではありません。そうではなく、各メソッドの入出力について考えることに集中してください。

### 配列

1.  `_.uniq` - uniq は引数として配列を受け取り、重複を除いた配列を返します。

### コレクション

1.  `_.map` - `_.each` に似ていますが、イテレータに値、キー（またはインデックス）、コレクションを渡し、すべての結果値を格納する新しい配列を返します。イテレータは、最終的に map によって返される新しい配列に格納される結果値を返す必要があります。この問題では `each` を使用する必要があります。

1.  `_.reject` - 真偽テストに合格しない配列中のすべての要素を返します。この問題では `filter` を使用する必要があります。

1.  `_.reduce` - 各要素に対して `iterator(accumulator, item)` を繰り返し呼び出すことにより、コレクションを単一の値にします。アキュムレータは、前回のイテレーター呼び出しの戻り値でなければなりません。

初期値を渡さなかった場合、コレクション内の最初の要素をアキュムレータとして使用することになります。

```js
const numbers = [1, 2, 3];
const accumulate = (result, int) => {
  return result + int;
};
const sum = _.reduce(numbers, accumulate(total, number), 0); // ---> 6
```

1.  `_.every` - すべての要素が真偽テストに合格するかどうかを決定します。ブール値を返し、コールバック（テスト）を受け取ってください。`_.reduce` を使用する必要があります。

### オブジェクト

1.  `_.extend` - メインオブジェクトを別のオブジェクトのプロパティを使って拡張します。最初の引数はメインオブジェクトであり、2 番目の引数はメインオブジェクトに追加するオブジェクトでなければなりません。可能であれば、`_.each` を使用してください。シャローコピーのみを作成します。

### 関数

これらは関数のデコレータです。関数のデコレータは関数を受け取り、少し異なる動作をする新しいバージョンの関数を返します。

1.  `_.once` - 一度だけ呼び出すことのできる関数を返します。後続の呼び出しは、以前に返した戻り値を返す必要があります。これにはクロージャを使用する必要があります。

1.  `_.memoize` - 引数として関数（入力関数）を受け取ります。入力関数の結果を取得して保存します（キャッシュ）。呼び出されたときに、与えられた引数の結果を既に計算しているかどうかを確認する関数を返す必要があります。可能であれば、キャッシュされた値を返すべきです。`JSON.stringify` を使いたいと思うかもしれません。入力関数は引数としてプリミティブな値のみを取ると仮定します。

1.  `_.invoke` - リスト内の各値に対して `methodOrKey` で指定されたメソッドを呼び出します。その他の追加の引数はないものと仮定します。

文字列であることに加えて、`methodOrKey` には関数自体を渡すこともできます。関数である場合、値をその関数に直接 apply できます。ここで [`apply`](http://ja.lmgtfy.com/?q=apply+javascript) を使用したいか、もしくは少なくともそれについて学びたいと思うかもしれません。

```js
_.invoke([[5, 1, 7], [3, 2, 1]], "sort");
// => [[1, 5, 7], [1, 2, 3]]
```

## 応用レベル

上記の課題が完了した場合にのみ、次の課題を行ってください。**これらのテストも作成する必要があります。** 応用レベルは必須ではありませんが、チャレンジしてみることを強くお勧めします。これらのメソッドは、Underscore ライブラリにもあります。詳細や例については、Underscore のドキュメントを見てみましょう！

常に、コミットすることを忘れないでください。

1.  `_.sortBy` - ソートされたコレクション（最初の引数）のコピーを返し、イテレータ（2 番目の引数）を通した各値の結果に基づいて昇順に並べます。イテレータは、ソートするプロパティの文字列名（長さなど）である場合もあります。

1.  `_.zip` - 同じインデックスである要素を持つ 2 つ以上の配列をひとつに圧縮します。

1.  `_.delay` - 指定したミリ秒数だけ関数を遅延させ、指定した引数を使って関数を呼び出します。

1.  `_.defaults` - `_.extend` と非常によく似ていますが、既に存在するキーは上書きされません。

1.  `_.throttle` - 呼び出されたときに、指定した時間内で一度だけトリガーできる関数を返します。

1.  応用レベルで実装した関数から１つ選び、その解法をまとめた Google slides を作成しましょう。
